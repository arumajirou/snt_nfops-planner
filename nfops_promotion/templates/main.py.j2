"""FastAPI serving template"""
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="{{ model_name }} Serving API",
    version="{{ api_version }}",
    description="Auto-generated serving API for {{ model_name }}"
)

# Pydantic models
class PredictionItem(BaseModel):
    unique_id: str = Field(..., description="Series identifier")
    ds: str = Field(..., description="Datetime in ISO format")
    exog: Optional[dict] = Field(None, description="Exogenous variables")


class PredictionRequest(BaseModel):
    model_name: str = "{{ model_name }}"
    version_or_stage: str = "{{ stage }}"
    quantiles: List[float] = [0.1, 0.5, 0.9]
    scenario_id: str = "base"
    items: List[PredictionItem]


class PredictionOutput(BaseModel):
    unique_id: str
    ds: str
    q: float
    y_hat: float


class PredictionResponse(BaseModel):
    run_id: str
    model_version: int
    scenario_id: str
    preds: List[PredictionOutput]


class VersionInfo(BaseModel):
    model_name: str
    version: int
    stage: str
    api_version: str


@app.get("/health")
async def health():
    """Health check"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}


@app.get("/version", response_model=VersionInfo)
async def version():
    """Get version info"""
    return {
        "model_name": "{{ model_name }}",
        "version": {{ version }},
        "stage": "{{ stage }}",
        "api_version": "{{ api_version }}"
    }


@app.post("/predict", response_model=PredictionResponse)
async def predict(request: PredictionRequest):
    """Make predictions"""
    logger.info(f"Prediction request for {len(request.items)} items")
    
    # Dummy prediction logic
    import random
    preds = []
    
    for item in request.items:
        for q in request.quantiles:
            # Simple random prediction (replace with actual model)
            base = random.uniform(50, 150)
            if q < 0.5:
                y_hat = base - (0.5 - q) * 20
            elif q > 0.5:
                y_hat = base + (q - 0.5) * 20
            else:
                y_hat = base
            
            preds.append({
                "unique_id": item.unique_id,
                "ds": item.ds,
                "q": q,
                "y_hat": y_hat
            })
    
    return {
        "run_id": "{{ run_id }}",
        "model_version": {{ version }},
        "scenario_id": request.scenario_id,
        "preds": preds
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
