name: pytest-heavy
on:
  workflow_dispatch: {}
  schedule:
    - cron: '30 19 * * *'   # UTC
  pull_request:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: true
permissions:
  contents: read
  pull-requests: write

jobs:
  heavy:
    if: >
      github.event_name != 'pull_request'
      || contains(github.event.pull_request.labels.*.name, 'heavy')
    runs-on: ubuntu-latest
    timeout-minutes: 90
    env:
      PYTEST_DISABLE_PLUGIN_AUTOLOAD: "1"

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements*.txt
            requirements-dev.txt

      - name: Install (dev heavy)
        run: |
          set -euxo pipefail
          python -m pip install -U pip
          pip install -e .[dev] pytest pytest-xdist pytest-rerunfailures "scipy>=1.11"

      - name: PyTest (heavy/slow + 1 rerun)
        id: run_pytest
        continue-on-error: true
        run: |
          set -o pipefail
          ec=0
          pytest -o addopts= -p xdist.plugin -p pytest_rerunfailures -vv \
                 -m "heavy or slow" \
                 -n auto --dist loadfile --durations=20 \
                 --maxfail=1 \
                 --reruns 1 --reruns-delay 2 \
                 2>&1 | tee pytest-output.txt || ec=$?
          echo "exitcode=${ec}" >> "$GITHUB_OUTPUT"

      - name: Summarize first failure and nodeid
        id: fail
        if: always()
        run: |
          set -eu
          nodeid="$(awk '
            /^FAILED[[:space:]]+/           {print $2; exit}
            /^ERROR collecting[[:space:]]+/ {print $3; exit}
          ' pytest-output.txt 2>/dev/null || true)"
          echo "nodeid=${nodeid}" >> "$GITHUB_OUTPUT"

          awk '
            BEGIN{grab=0}
            /^=+ FAILURES =+/ {grab=1; print; next}
            grab && /^=+ .* =+$/ {exit}
            grab {print}
          ' pytest-output.txt > first-failure.txt || true

          if [ ! -s first-failure.txt ]; then
            awk '
              /^(ERROR collecting|ERROR: usage: pytest)/ {grab=1}
              grab {print; if(++n>=120) exit}
            ' pytest-output.txt > first-failure.txt || true
          fi

          {
            echo "### pytest-heavy first failure (trimmed)"
            echo
            if [ -s first-failure.txt ]; then
              echo '```text'
              sed -n '1,200p' first-failure.txt
              echo '```'
            else
              echo "- no failure block detected (likely pre-collection failure)"
            fi
            echo
            echo "### pytest-heavy failure summary"
            if [ -n "${nodeid:-}" ]; then
              echo
              echo "- nodeid: \`${nodeid}\`"
              echo "- local reproduce:"
              echo '  ```bash'
              echo "  pytest -vv -n 0 --maxfail=1 \"${nodeid}\""
              echo '  ```'
            else
              echo
              echo "- no FAILED/ERROR collecting lines; likely pre-collection failure"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Comment nodeid to PR
        if: always() && github.event_name == 'pull_request' && steps.run_pytest.outputs.exitcode != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const marker = "<!-- pytest-heavy-repro -->";
            const nodeid = `${{ steps.fail.outputs.nodeid }}`;
            const trimmed = fs.existsSync("first-failure.txt")
              ? "```text\n" + fs.readFileSync("first-failure.txt", "utf8").split("\n").slice(0,200).join("\n") + "\n```"
              : "- no failure block detected (likely pre-collection failure)";
            let body = `${marker}\n### pytest-heavy failure summary\n\n${trimmed}\n\n`;
            if (nodeid) {
              body += `- nodeid: \`${nodeid}\`\n- local reproduce:\n\`\`\`bash\npytest -vv -n 0 --maxfail=1 "${nodeid}"\n\`\`\`\n`;
            } else {
              body += `- no FAILED/ERROR collecting lines; likely pre-collection failure\n`;
            }
            const pr = context.payload.pull_request.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: pr, per_page: 100
            });
            const mine = comments.find(c => c.user.type === "Bot" && c.body?.includes(marker));
            if (mine) {
              await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr, body });
            }

      - name: Finalize job result
        if: always()
        run: |
          [ "${{ steps.run_pytest.outputs.exitcode }}" != "0" ] && exit 1 || exit 0
